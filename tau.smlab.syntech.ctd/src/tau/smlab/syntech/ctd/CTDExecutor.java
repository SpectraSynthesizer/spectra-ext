/*
Copyright (c) since 2015, Tel Aviv University and Software Modeling Lab

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Tel Aviv University and Software Modeling Lab nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Tel Aviv University and Software Modeling Lab 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/

package tau.smlab.syntech.ctd;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

import net.sf.javabdd.BDD;
import net.sf.javabdd.BDDDomain;
import tau.smlab.syntech.games.controller.Controller;
import tau.smlab.syntech.games.controller.StaticController;
import tau.smlab.syntech.games.controller.jits.BasicJitController;
import tau.smlab.syntech.jtlv.Env;
import tau.smlab.syntech.jtlv.env.module.ModuleBDDField;

public abstract class CTDExecutor {

	protected Map<String, String[]> sysVars;
	protected Map<String, String[]> envVars;
	protected boolean jumped;
	protected int testNumber;
	protected int stateNumber;
	protected Set<DefaultMutableTreeNode> visited;
	protected Controller controller;
	protected DefaultTreeModel statesTree;
	protected DefaultMutableTreeNode currentNode;
	protected int totalTests;
	protected int totalStates;
	protected boolean lastVisited;
	
	/**
	 * An abstract class representing an executor of a CTD test suite.
	 * @param outFolder The "out" folder containing the symbolic controller of the specification to be tested.
	 * @param name The name of the specification
	 * @param treeFilePath The ".spectra_tree" file generated by computing a CTD test suite.
	 * @param bddsFolder The folder containing the BDDs computed by a CTD test suite.
	 * @param reordering Should reordering be enabled?
	 * @param useJitController Use a JIT controller or a static controller
	 * @throws ClassNotFoundException If there was an error parsing one of the files.
	 * @throws IOException If a file could not be read.
	 */
	public CTDExecutor(String outFolder, String name, String treeFilePath, String bddsFolder,
			boolean reordering, boolean useJitController) throws ClassNotFoundException, IOException {
		sysVars = new HashMap<>();
		envVars = new HashMap<>();
		
		CoverageWrapper.loadVariables(outFolder, name, sysVars, envVars);
		Controller controller = useJitController ? new BasicJitController() : new StaticController();
		
		controller.load(outFolder, name, sysVars, envVars);
//		Controller controller = new BasicJitController();
//		controller.load(outFolder, name, sysVars, envVars);
		
		if (reordering) {
			Env.enableReorder();
		} else {
			Env.disableReorder();
		}
		
		statesTree = CoverageWrapper.LoadFromFile(treeFilePath, bddsFolder);
		
		visited = new HashSet<DefaultMutableTreeNode>();
		jumped = true;
		currentNode = (DefaultMutableTreeNode)(statesTree.getRoot());
		testNumber = 1;
		stateNumber = 0;
		lastVisited = false;
		
		totalStates=-1;
		updateTotals((DefaultMutableTreeNode) statesTree.getRoot());
	}
	
	/**
	 * @return The total number of tests in the test suite.
	 */
	public int getTotalTests() {
		return totalTests;
	}
	
	/**
	 * @return The total number of states in the test suite.
	 */
	public int getTotalStates() {
		return totalStates;
	}
	
	/**
	 * @return The number of the current test, starting from 1. 
	 */
	public int getTestNumber() {
		return testNumber;
	}
	
	/**
	 * @return The number of the current state in a test, starting from 1.
	 */
	public int getStateNumber() {
		return stateNumber;
	}
	
	/**
	 * Advance states until the next test starts.
	 */
	public void advanceToNextTest() {
		getNext();
		while(!jumped) {
			getNext();
		}
	}
	
	// TODO consider adding this function
//	public double getCoverageFraction() {
//		
//	}
	
	/**
	 * Advance to the next state in the test.
	 * Will advance to the first state of the next test.
	 */
	public void updateState() {
		getNext();
	}
	
	/**
	 * Advance to the next state in the test.
	 * Will advance to the first state of the next test.
	 * @return The BDD of the current state after advancing.
	 */
	public abstract BDD getNext();
	
	/**
	 * @return true if the current state the last state of all tests in the suite.
	 */
	public boolean hasNext() {
		return visited.size() != totalStates;
	}
	
	/**
	 * @return true if the current state is the first state in a test. (A.K.A. a "jump" has occurred between states).
	 */
	public boolean wasJumped() {
		return jumped;
	}
	
	/**
	 * @return true if the current state is the last state in a test.
	 */
	public boolean isEndOfTest() {
		return currentNode.isLeaf();
	}
	
	/**
	 * @return true if the current state was visited before in a previous test.
	 */
	public boolean wasVisited() {
		return lastVisited;
	}
	
	/**
	 * @return A BDD of the current state.
	 */
	public BDD getCurrentState() {
		return (BDD)(currentNode.getUserObject());
	}
	
	/*----------------------------------FROM CONTROLLER EXECUTOR---------------------------------------*/
	/**
	 * Returns the set of all output (system controlled) variables' names
	 * @return the set of all output (system controlled) variables' names
	 */
	public Map<String, String[]> getSysVars() {
		return sysVars;
	}
	
	/**
	 * Returns the set of all input (environment controlled) variables' names
	 * @return the set of all input (environment controlled) variables' names
	 */
	public Map<String, String[]> getEnvVars() {
		return envVars;
	}
	
	/**
	 * Returns the current value of the specified variable name (either an input or an output)
	 *
	 * @param varName The variable name
	 * @return The variable value
	 * @throws IllegalArgumentException if the variable name does not exist in the controller
	 * @throws IllegalStateException if the current state is zero
	 */
	public String getCurrValue(String varName) throws IllegalArgumentException, IllegalStateException {
		BDD currentState = (BDD) currentNode.getUserObject();
		if (currentState.isZero()) {
			throw new IllegalStateException("Current state is zero. Check if controller is in deadlock");
		}

		ModuleBDDField field = Env.getVar(varName);
		if (field == null) {
			throw new IllegalArgumentException("The variable name " + varName + " does not exist in the controller");
		} 

		BDDDomain domain = field.getDomain();
		return Env.getValueByDomain(currentState, domain);
	}
	
	private Map<String, String> getModuleValues(Set<String> moduleVarNames) throws IllegalArgumentException, IllegalStateException {
		Map<String, String> varToVal = new HashMap<>();
		for (String varName : moduleVarNames) {
			varToVal.put(varName, getCurrValue(varName));
		}
		return varToVal;
	}
	
	/**
	 * Returns a mapping of all system variables' names to their current values
	 * @return a mapping of all system variables' names to their current values
	 */
	public Map<String, String> getCurrOutputs() throws IllegalArgumentException {
		return getModuleValues(sysVars.keySet());
	}

	/**
	 * Returns a mapping of all environment variables' names to their current values
	 * @return a mapping of all environment variables' names to their current values
	 */
	public Map<String, String> getCurrInputs() throws IllegalArgumentException {
		return getModuleValues(envVars.keySet());
	}
	
	/**
	 * Returns a mapping of all specified variables' names to their current values.
	 * Each variable name may refer to either an input or an output variable
	 * 
	 * @param varNames the variables' names that will be mapped to their current values
	 * @return the variables' values as a map between variable name and its value
	 * @throws IllegalArgumentException if there is a variable name that does not exist in the controller
	 */
	public Map<String, String> getCurrValues(String ... varNames) throws IllegalArgumentException {
		return getModuleValues(new HashSet<>(Arrays.asList(varNames)));
	}
	
	/*----------------------------------PRIVATE FUNCTIONS---------------------------------------*/
	private void updateTotals(DefaultMutableTreeNode node) {
		totalStates++;
		if (node.isLeaf()) {
			totalTests++;
		} else {
			for (int i=0; i<node.getChildCount(); i++) {
				DefaultMutableTreeNode child = (DefaultMutableTreeNode)(node.getChildAt(i));
				updateTotals(child);
			}
		}
	}
}